name: Update README Dynamically
on:
  schedule:
    # Roda a cada hora
    - cron: '0 * * * *'
  workflow_dispatch:

jobs:
  update:
    runs-on: ubuntu-latest
    permissions:
      contents: write # Permissão para escrever no repositório

    steps:
      - uses: actions/checkout@v3

      - name: Get Last Commit from GitHub API (Robust Version)
        id: last_commit
        run: |
          EVENT_DATA=$(curl -s "https://api.github.com/users/RenatofilhoDevandtech/events/public")
          LATEST_PUSH=$(echo "$EVENT_DATA" | jq '[.[] | select(.type=="PushEvent")][0]')

          if [[ "$LATEST_PUSH" == "null" ]]; then
            REPO_NAME="N/A"
            COMMIT_MESSAGE="Nenhum commit público recente encontrado."
          else
            REPO_NAME=$(echo "$LATEST_PUSH" | jq -r '.repo.name')
            COMMIT_MESSAGE=$(echo "$LATEST_PUSH" | jq -r '.payload.commits[0].message')
          fi
          
          echo "repo_full_name=$REPO_NAME" >> $GITHUB_OUTPUT
          echo "message=$COMMIT_MESSAGE" >> $GITHUB_OUTPUT

      - name: Ask AI to improve commit message
        id: commit_suggester
        run: |
          PROMPT="Aja como um desenvolvedor sênior. Reescreva a seguinte mensagem de commit para seguir o padrão Conventional Commits (ex: 'feat(auth): Adiciona login com Google'). Seja conciso, técnico e retorne APENAS a mensagem sugerida, sem nenhum texto ou formatação adicional. A mensagem é: '${{ steps.last_commit.outputs.message }}'"
          JSON_PAYLOAD=$(jq -n --arg prompt "$PROMPT" '{contents: [{parts: [{text: $prompt}]}]}')
          API_RESPONSE=$(curl -s -X POST "https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash-latest:generateContent?key=${{ secrets.GEMINI_API_KEY }}" \
            -H "Content-Type: application/json" \
            -d "$JSON_PAYLOAD")
          SUGGESTION=$(echo "$API_RESPONSE" | jq -r '.candidates[0].content.parts[0].text' | tr -d '\n' | tr -d '`' | sed 's/\"//g')
          echo "gemini_text=$SUGGESTION" >> $GITHUB_OUTPUT

      - name: Update README file
        env:
          REPO_FULL_NAME: ${{ steps.last_commit.outputs.repo_full_name }}
          COMMIT_MESSAGE: ${{ steps.last_commit.outputs.message }}
          AI_SUGGESTION: ${{ steps.commit_suggester.outputs.gemini_text }}
        run: |
          # Gera o novo conteúdo em um arquivo temporário
          cat <<EOF > new_content.html
          <table width="100%">
            <tr>
              <td width="20%"><b>Última Atividade em:</b></td>
              <td><a href="https://github.com/$REPO_FULL_NAME"><b>$REPO_FULL_NAME</b></a></td>
            </tr>
            <tr>
              <td width="20%"><b>Meu Último Commit:</b></td>
              <td><code>$COMMIT_MESSAGE</code></td>
            </tr>
            <tr>
              <td width="20%"><b>Sugestão da IA:</b></td>
              <td><code>$AI_SUGGESTION</code></td>
            </tr>
          </table>
          EOF

          # Script Python "à prova de falhas" que reconstrói o README
          python -c "
          import os
          
          readme_path = 'README.md'
          start_marker = ''
          end_marker = ''
          
          with open('new_content.html', 'r') as f:
              new_content_body = f.read()
          
          # Lê o README linha por linha e reconstrói
          new_readme_lines = []
          in_block = False
          with open(readme_path, 'r') as f:
              for line in f:
                  if start_marker in line:
                      new_readme_lines.append(line)
                      new_readme_lines.append(new_content_body + '\n')
                      in_block = True
                  elif end_marker in line:
                      new_readme_lines.append(line)
                      in_block = False
                  elif not in_block:
                      new_readme_lines.append(line)
          
          # Sobrescreve o README com o conteúdo limpo e reconstruído
          with open(readme_path, 'w') as f:
              f.writelines(new_readme_lines)
          "

      - name: Commit and push changes
        run: |
          if [[ -n "$(git status --porcelain README.md)" ]]; then
            git config --global user.name 'GitHub Actions Bot'
            git config --global user.email 'github-actions[bot]@users.noreply.github.com'
            git add README.md
            git commit -m "chore(readme): Update latest activity"
            git push
          else
            echo "README is already up to date."
          fi
